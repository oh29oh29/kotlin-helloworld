# 코틀린 Hello world!

### Hello, world

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다.
- 함수를 최상위 레벨에 정의할 수 있다. (꼭 클래스 안에 함수를 넣을 필요가 없다)
- 배열도 일반적인 클래스와 마찬가지다. (배열 처리를 위한 문법이 따로 존재하지 않는다)
- System.out.println 대신 println 이라고 쓴다. 코틀린 표준 라이브러리는 여러 가지 자바 표준 라이브러리 함수를 쉽게 사용할 수 있게 wrapper를 제공한다.
- 줄 끝에 세미콜론을 붙이지 않아도 좋다.

### 함수

##### 함수 정의
```kotlin
fun max(a: Int, b: Int) : Int {
    return if (a > b) a else b
}
```

- 루프를 제외한 대부분의 제어 구조가 식이다.
- 대입문은 문이다.

##### 식이 본문인 함수
```kotlin
fun max(a: Int, b: Int) : Int = if (a > b) a else b
``` 
- 식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 변환 타입으로 정해준다. (타입 추론)
- 식이 본문인 함수의 반환 타입만 생략 가능하다.

### 변수

- 코틀린에서 타입 지정을 생략하는 경우가 흔하다.
- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없기 때문에 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

##### 타입 명시

```kotlin
val number: Int = 1
```

##### 타입 생략

```kotlin
val number = 1
```

##### 타입과 초기화

- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
 
```kotlin
val number: Int
number = 1
```

##### 변경 가능한 변수 / 변경 불가능한 변수

- val
    - 변경 불가능한 참조를 저장하는 변수
    - 초기화하고 나면 변경이 불가능하다
    - 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수 있다.
- var
    - 변경 가능한 참조를 저장하는 변수
 
 ##### 문자열 템플릿
 
 ```kotlin
fun main(args: Array<String>) {
    val name = if (args.size > 0) args[0] else "Kotlin"
    println("Hello, $name!")
}
```

- 복잡한 식도 중괄호({})로 감싸서 문자열 템플릿 안에 넣을 수 있다.
```kotlin
fun main(args: Array<String>) {
    if (args.size > 0) {
        println("Hello, ${args[0]}!")
    }
}
```